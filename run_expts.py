# TODO sort out source code in this project this is hacky
import sys

from helpers.model_load import get_model_output_paths, load_model
from helpers.save_images import get_output_folder
sys.path.extend([
    'src'
])
import json
import argparse
from lib.parameters import DeforumAnimArgs, Root, DeforumArgs
from pathlib import Path
from helpers.render import do_render


def easy_to_type(s:str):
    return s.replace(" ", "_")

def init_deforumargs(img:DeforumArgs, root:Root, motion:DeforumAnimArgs, filename, general_style:str):
    # Additional properties of DeforumArgs that are visible in colab.
    # The DeforumArgs class is autogenerated from that, so we can't add them to the class definition.
    # TODO where things like -- DeforumArgs, Root etc is a bit confusing and could well be refactored
    #img.batch_name = f"{easy_to_type(Path(filename).stem)}--{img.get_filesystem_friendly_changed_attributes()}-{motion.get_filesystem_friendly_changed_attributes()}-{root.get_filesystem_friendly_changed_attributes()}-{general_style}"
    img.batch_name = easy_to_type(Path(filename).stem)
    img.outdir = get_output_folder(root.output_path, img.batch_name)

    img.W, img.H = map(lambda x: x - x % 64, (img.W, img.H))  # resize to integer multiple of 64
    img.n_samples = 1 # doesnt do anything
    img.precision = 'autocast' 
    img.C = 4
    img.f = 8

    img.prompt = ""
    img.timestring = ""
    img.init_latent = None
    img.init_sample = None
    img.init_sample_raw = None
    img.mask_sample = None
    img.init_c = None
    img.seed_internal = 0

    img.dynamic_threshold = None
    img.static_threshold = None   

    img.strength_0_no_init = True


def create_movie_frames(filename, img:DeforumArgs, motion:DeforumAnimArgs, root:Root, prompts:dict, general_style: str):
    print(f"batch name: {img.batch_name}")
    do_render(img, motion, root, prompts, general_style)

def generate_combinations(properties, current_combination, index:int):
    if index == len(properties):
        yield current_combination
    else:
        prop_names, prop_values = properties[index]
        for value_set in prop_values:
            new_combination = current_combination.copy()
            if len(prop_names) == 1:  # Single property e.g. "img.sampler": ["dpm2", "heun",  "euler_ancestral"]
                prop_name = prop_names[0]
                if prop_name.startswith("img."):
                    img_prop_name = prop_name.split(".")[1]
                    if "img" not in new_combination:
                        new_combination["img"] = {}
                    new_combination["img"][img_prop_name] = value_set
                elif prop_name.startswith("motion."):
                    motion_prop_name = prop_name.split(".")[1]
                    if "motion" not in new_combination:
                        new_combination["motion"] = {}
                    new_combination["motion"][motion_prop_name] = value_set
                elif prop_name.startswith("root."):
                    root_prop_name = prop_name.split(".")[1]
                    if "root" not in new_combination:
                        new_combination["root"] = {}
                    new_combination["root"][root_prop_name] = value_set

            else:  # Multiple properties that only make sense together e.g. "img.H, img.W": [[512,512],[768,768]],
                img_dict = {}
                motion_dict = {}
                root_dict = {}
                for prop_name, value in zip(prop_names, value_set):
                    if prop_name.startswith("img."):
                        img_prop_name = prop_name.split(".")[1]
                        img_dict[img_prop_name] = value
                    elif prop_name.startswith("motion."):
                        motion_prop_name = prop_name.split(".")[1]
                        motion_dict[motion_prop_name] = value
                    elif prop_name.startswith("root."):
                        root_prop_name = prop_name.split(".")[1]
                        root_dict[root_prop_name] = value
                if img_dict:
                    if "img" not in new_combination:
                        new_combination["img"] = {}
                    new_combination["img"].update(img_dict)
                if motion_dict:
                    if "motion" not in new_combination:
                        new_combination["motion"] = {}
                    new_combination["motion"].update(motion_dict)
                if root_dict:
                    if "root" not in new_combination:
                        new_combination["root"] = {}
                    new_combination["root"].update(root_dict)
            yield from generate_combinations(properties, new_combination, index + 1)

# when doing experiments, we might end up loading lots of models. 
# we don't want to reload the same one all the time, but we also
# don't want to keep all of them in memory. weakref.WeakValueDictionary is a way to 
# give Python the authority to discard entries if memory runs low. 
# (The models can take upwards of 12GB RAM each.)

import weakref
class ModelWrapper:
    def __init__(self, model_tuple):
        self.model_tuple = model_tuple
_cache = weakref.WeakValueDictionary()

def load_model_cached(root, load_on_run_all=True, check_sha256=True, map_location=None):
    model_checkpoint = root.model_checkpoint

    if model_checkpoint not in _cache:
        model_tuple = load_model(root, load_on_run_all=load_on_run_all, check_sha256=check_sha256, map_location=map_location)
        _cache[model_checkpoint] = ModelWrapper(model_tuple)

    return _cache[model_checkpoint].model_tuple

def init_model(root:Root):
    root.models_path, root.output_path = get_model_output_paths(root)
    print(f"loading model from {root.models_path}")
    # TODO model and device are not input parameters in the original ipynb so didn't propagate to Root class in my export script
    #root.model, root.device = load_model_cached(root, load_on_run_all=True, check_sha256=True, map_location=root.map_location)
    
    # TODO figure out how to cache this properly. If we use weak references the model is flushed right away :)
    root.model, root.device = load_model(root, load_on_run_all=True, check_sha256=True, map_location=root.map_location)
    print(f"loaded model {root.model} on device {root.device}") # type: ignore

def extract_properties(combinations, dictionary_name):
    extracted_properties = []
    for keys, values in combinations.items():
        key_list = keys.split(",")
        prop_names = [key.strip() for key in key_list]
        if dictionary_name == "img":
            prop_names = [prop_name for prop_name in prop_names if prop_name.startswith("img.")]
        elif dictionary_name == "motion":
            prop_names = [prop_name for prop_name in prop_names if prop_name.startswith("motion.")]
        elif dictionary_name == "root":
            prop_names = [prop_name for prop_name in prop_names if prop_name.startswith("root.")]
        if prop_names:
            extracted_properties.append((prop_names, values))
    if not extracted_properties:
        print(f"No {dictionary_name} properties found")
    else:
        print(f"Extracted {dictionary_name} properties: {extracted_properties}")
    return extracted_properties

parser = argparse.ArgumentParser()
parser.add_argument('--input', type=str, required=True, help='Path to the input JSON file')
parser.add_argument("--mp3-dir", default="music", help="Location of MP3 files in config file.")
args = parser.parse_args()

input_file = args.input
with open(input_file, "r") as file:
    batch_settings = json.load(file)

# pull data from the batch settings file
compositions = batch_settings["compositions"]
combinations = batch_settings["combinations"]

# we may want to restrict the number of frames from a specific item in the batch to do sampling
#TODO if max_frames isn't set we assume go whole duration of the song
max_frames = batch_settings["num_key_frames"]

print(f"Combinations: {combinations}")
img_properties = extract_properties(combinations, "img")
motion_properties = extract_properties(combinations, "motion")
root_properties = extract_properties(combinations, "root")

img_combinations = [{} for _ in range(len(img_properties))]
motion_combinations = [{} for _ in range(len(motion_properties))]
root_combinations = [{} for _ in range(len(root_properties))]

mp3_dir = args.mp3_dir
count = 0
for composition in compositions:
    # pull metadata from analysis file
    analysis_file = mp3_dir / Path(Path(composition).stem + "-analysis/full-metadata.json")
    analysis_data = analysis_file.read_text()
    # read analysis data into a json object 
    analysis_data = json.loads(analysis_data)

    zoom = analysis_data['animation']['keyframe_zoom_animations']
    # style is appended to the end of every prompt to present a consistent style
    style = analysis_data['style']
    prompts = {}
    for key, value in analysis_data['keyframes'].items():
        prompts[int(key)] = value['prompt']

    print(f'== {composition}:')
    print(f'zoom: "{zoom[:60]}..."')
    print(f'prompts:\n{json.dumps(prompts,indent=2)}\n\n')

    for img_combination in generate_combinations(img_properties, {}, 0):
        for motion_combination in generate_combinations(motion_properties, {}, 0):
            for root_combination in generate_combinations(root_properties, {}, 0):
                root_instance = Root()
                if "root" in root_combination:
                    for prop_name, value in root_combination["root"].items():
                        setattr(root_instance, prop_name, value)
                init_model(root_instance)
                
                motion_instance = DeforumAnimArgs()
                motion_instance.max_frames = max_frames
                if "motion" in motion_combination:
                    for prop_name, value in motion_combination["motion"].items():
                        setattr(motion_instance, prop_name, value)

                img_instance = DeforumArgs()
                if "img" in img_combination:
                    #print(f"### img_combination: {img_combination}")
                    for prop_name, value in img_combination["img"].items():
                        setattr(img_instance, prop_name, value)
                init_deforumargs(img_instance, root_instance, motion_instance, composition, style)

                count += 1
                create_movie_frames(composition, img_instance, motion_instance, root_instance, prompts, style)

print(f"{count} combinations generated")
